//------------------------------------------------------------------------------
// <auto-generated>
//	@Author Quan
//  @Time 2015-12-31
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

/// 用FixedUpdate更新，帧率会受限制于FixedUpdate更新频率
/// 最低帧率0.0001f
[DisallowMultipleComponent]
public class ZUIFrameAnimation : ZUIImage
{
	public System.Action<ZUIImage, string, string> SetImgeFunc;
    public Func<string, string, Sprite> SpriteGetter;
	private string[] frameNames;
	private string frameAtlas;

	private Sprite[] frameSprites;
	private DateTime lastFrameTime;
	private bool forwardWay;

	/// <summary>
	/// 帧率,用FixedUpdate更新
	/// </summary>
	public float FrameRate{ get; private set; }

	/// <summary>
	/// 帧动画是否在运行
	/// </summary>
	public bool IsRuning{ get; private set; }

	/// <summary>
	/// 当前帧位置
	/// </summary>
	public int CurrentFameIndex{ get; private set; }

	/// <summary>
	/// 总帧数
	/// </summary>
	public int FrameCount
	{
		get{
			if( frameSprites != null )
				return frameSprites.Length;
			if( frameNames != null )
				return frameNames.Length;
			return 0;
		} 
	}

	/// <summary>
	/// 循环播放
	/// </summary>
	public bool Loop { get; private set; }

	/// <summary>
	/// 来回循环方式，loop=true生效
	/// </summary>
	public bool BounceLoop{ get; private set; }

	/// <summary>
	/// 每帧回调
	/// </summary>
	private Dictionary< int, Action > keyCallBacks = new Dictionary<int, Action>();

	/// <summary>
	/// 初始化动画
	/// </summary>
	/// <param name="frames">帧集合</param>
	/// <param name="frameRate">帧率(每秒切换几张纹理)</param>
	/// <param name="loop">是否循环播放</param>
	/// <param name="bounceLoop">是否来回循环方式（不是则为一般循环方式）</param>
	/// <param name="startAnimationNow">是否立即播放</param>
	public void Initialize( Sprite[] frames, float frameRate, bool loop = true, bool bounceLoop = false, bool startAnimationNow = true )
	{
		if( frames == null || frames.Length == 0 )
		{
			Debug.LogError( "帧序列不能为空" );
			return;
		}
		Loop = loop;
		frameNames = null;
		BounceLoop = bounceLoop;
		frameSprites = frames;
		FrameRate = Mathf.Max( frameRate, 0.0001f );
		if( startAnimationNow )
		{
			if( !loop )
				StartAnimationOnce( 0 );
			else
				StartAnimationWithLoop( 0, bounceLoop );
		}
	}

	/// <summary>
	/// 初始化动画
	/// </summary>
	/// <param name="frameNames">每帧对应的文理名字</param>
	/// <param name="atlas">纹理集名字</param>
	/// <param name="getImgDelegate">设置纹理函数</param>
	/// <param name="frameRate">帧率(每秒切换几张纹理)</param>
	/// <param name="loop">是否循环播放</param>
	/// <param name="bounceLoop">是否来回循环方式（不是则为一般循环方式）</param>
	/// <param name="startAnimationNow">是否立即播放</param>
	public void Initialize( string[] fraNames, string atlas, System.Action<ZUIImage, string, string> getImgDelegate, float frameRate, bool loop = true, bool bounceLoop = false, bool startAnimationNow = true )
	{
		Loop = loop;
		BounceLoop = bounceLoop;
		frameNames = fraNames;
		frameAtlas = atlas;
		SetImgeFunc = getImgDelegate;
		frameSprites = null;
		SpriteGetter = null;
		FrameRate = Mathf.Max( frameRate, 0.0001f );
		if( startAnimationNow )
		{
			if( !loop )
				StartAnimationOnce( 0 );
			else
				StartAnimationWithLoop( 0, bounceLoop );
		}
	}

	/// <summary>
	/// 初始化动画
	/// </summary>
	/// <param name="frameNames">每帧对应的文理名字</param>
	/// <param name="atlas">纹理集名字</param>
	/// <param name="spriteDelege">获取纹理函数</param>
	/// <param name="frameRate">帧率(每秒切换几张纹理)</param>
	/// <param name="loop">是否循环播放</param>
	/// <param name="bounceLoop">是否来回循环方式（不是则为一般循环方式）</param>
	/// <param name="startAnimationNow">是否立即播放</param>
	public void Initialize( string[] fraNames, string atlas, Func<string, string, Sprite> spriteDelege, float frameRate, bool loop = true, bool bounceLoop = false, bool startAnimationNow = true )
	{
		Loop = loop;
		BounceLoop = bounceLoop;
		frameNames = fraNames;
		frameAtlas = atlas;
		SetImgeFunc = null;
		frameSprites = null;
		SpriteGetter = spriteDelege;
		FrameRate = Mathf.Max( frameRate, 0.0001f );
		if( startAnimationNow )
		{
			if( !loop )
                StartAnimationOnce( 0 );
            else
                StartAnimationWithLoop( 0, bounceLoop );
        }
    }
    

	/// <summary>
	/// 播放一次动画
	/// </summary>
	/// <param name="fromFrame">起始帧</param>
	public void StartAnimationOnce( int fromFrame = 0 )
	{
		Loop = false;
		IsRuning = true;
		CurrentFameIndex = fromFrame;
		showCurrentFrame();
	}

	/// <summary>
	/// 循环播放动画
	/// </summary>
	/// <param name="fromFrame">起始帧</param>
	/// <param name="bounce">是否来回播放</param>
	public void StartAnimationWithLoop( int fromFrame = 0, bool bounce = false )
	{
		Loop = true;
		IsRuning = true;
		BounceLoop = bounce;
		CurrentFameIndex = fromFrame;
		showCurrentFrame();
	}

	public void ResumeAnimation()
	{
		IsRuning = true;
	}

	public void StopAnimation()
	{
		IsRuning = false;
		CurrentFameIndex = 0;
		Loop = false;
		BounceLoop = false;
	}

	public void PauseAnimation()
	{
		IsRuning = false;
	}

	/// <summary>
	/// 添加关键帧回调,循环播放时也会触发
	/// </summary>
	public void AddFrameCallBack( int frame, Action callback )
	{
		if( keyCallBacks.ContainsKey( frame ) )
			keyCallBacks[frame] += callback;
		else
			keyCallBacks.Add( frame, callback );
	}

	/// <summary>
	/// 移除关键帧回调
	/// </summary>
	public void RemoveFrameCallBack( int frame, Action callback )
	{
		if( keyCallBacks.ContainsKey( frame ) )
		{
			if( keyCallBacks[frame] == callback )
				keyCallBacks.Remove( frame );
			else
				keyCallBacks[frame] -= callback;
		}
	}

	void FixedUpdate()
	{
		if( IsRuning )
		{
			tryShowNextFrame();
		}
	}

	/// <summary>
	/// 尝试更新当前帧
	/// </summary>
	private void tryShowNextFrame()
	{
		if( DateTime.Now.Subtract( lastFrameTime ).TotalMilliseconds >= (1f/FrameRate)*1000 )
		{
			lastFrameTime = DateTime.Now;
			if( !Loop )
			{
				CurrentFameIndex ++;
				if( CurrentFameIndex >= FrameCount )
				{
					IsRuning = false;
					return;
				}
			}else
			{
				if( !BounceLoop )
				{
					CurrentFameIndex ++;
					if( CurrentFameIndex >= FrameCount )
						CurrentFameIndex = 0;
				}else
				{
					if( forwardWay )
					{
						if( CurrentFameIndex == FrameCount - 1 )
						{
							forwardWay = false;
							CurrentFameIndex --;
						}else
						{
							CurrentFameIndex ++;
						}
					}else
					{
						if( CurrentFameIndex == 0 )
						{
							forwardWay = true;
							CurrentFameIndex ++;
						}else
						{
							CurrentFameIndex --;
						}
					}
				}
				showCurrentFrame();
			}
		}
	}

	/// <summary>
	/// 显示当前帧纹理
	/// </summary>
	private void showCurrentFrame()
	{
		if( frameSprites != null && frameSprites.Length > CurrentFameIndex )
		{
			this.sprite = frameSprites[CurrentFameIndex];
		}else
		{
			if( frameNames != null && frameNames.Length > CurrentFameIndex )
			{
				if( SetImgeFunc != null )
					SetImgeFunc( this, frameAtlas, frameNames[CurrentFameIndex] );
				else if( SpriteGetter != null )
					this.sprite = SpriteGetter( frameAtlas, frameNames[CurrentFameIndex] );
			}
		}

		//回调
		if( keyCallBacks.ContainsKey( CurrentFameIndex ) && keyCallBacks[CurrentFameIndex] != null )
			keyCallBacks[CurrentFameIndex]();
	}

    protected override void OnDestroy()
    {
 	    base.OnDestroy();
		frameSprites = null;
		IsRuning = false;
		Loop = false;
		BounceLoop = false;
		CurrentFameIndex = -1;
		keyCallBacks.Clear();
	}
}

